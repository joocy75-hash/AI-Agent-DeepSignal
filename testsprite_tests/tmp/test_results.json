[
  {
    "projectId": "7907cc9c-a3f2-4224-b26e-c0b5513fc8cc",
    "testId": "6924cccd-ec7a-4687-aae2-9f0a4736643a",
    "userId": "7438b4f8-1041-70be-62a0-849244df0173",
    "title": "TC001-user authentication including oauth login and jwt token handling",
    "description": "Test the user authentication flow including email/password login, OAuth login via Google and Kakao, JWT token issuance, validation, and expiration handling to ensure secure and seamless user access.",
    "code": "import requests\nimport time\nimport jwt\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\ndef test_user_authentication_oauth_jwt_handling():\n    session = requests.Session()\n\n    # 1. Test email/password login (Register and login)\n    user_email = \"testuser@example.com\"\n    user_password = \"TestPass123!\"\n\n    # Cleanup function to delete user if created during test\n    user_id = None\n    tokens = {}\n\n    try:\n        # Register user\n        register_payload = {\n            \"email\": user_email,\n            \"password\": user_password\n        }\n        r = session.post(f\"{BASE_URL}/auth/register\", json=register_payload, timeout=TIMEOUT)\n        # Accept 201 Created or 400 if already registered (but assume test DB)\n        assert r.status_code in (201, 400)\n        if r.status_code == 201:\n            user_id = r.json().get(\"id\")\n        elif r.status_code == 400:\n            # Try to login anyway if exists\n            pass\n        else:\n            assert False, \"Unexpected register response\"\n\n        # Login user with email/password\n        login_payload = {\n            \"email\": user_email,\n            \"password\": user_password\n        }\n        r = session.post(f\"{BASE_URL}/auth/login\", json=login_payload, timeout=TIMEOUT)\n        assert r.status_code == 200, f\"Login failed with status {r.status_code}\"\n        login_data = r.json()\n        assert \"access_token\" in login_data and \"refresh_token\" in login_data\n        tokens['jwt_access_token'] = login_data[\"access_token\"]\n        tokens['jwt_refresh_token'] = login_data[\"refresh_token\"]\n\n        # Validate JWT token (decode without verification to inspect claims)\n        try:\n            decoded_token = jwt.decode(tokens['jwt_access_token'], options={\"verify_signature\": False})\n            assert \"sub\" in decoded_token\n            assert decoded_token.get(\"exp\") > time.time()\n        except Exception as ex:\n            assert False, f\"JWT token decoding failed: {ex}\"\n\n        # 2. Test OAuth login via Google\n        # Mock the OAuth token verification response by sending a fake token to the backend.\n        # Assume endpoint: POST /auth/oauth/google with payload { \"token\": \"mock_google_token\" }\n        google_oauth_payload = {\"token\": \"mock_google_token\"}\n        r = session.post(f\"{BASE_URL}/auth/oauth/google\", json=google_oauth_payload, timeout=TIMEOUT)\n        assert r.status_code == 200, f\"Google OAuth login failed with status {r.status_code}\"\n        google_oauth_data = r.json()\n        assert \"access_token\" in google_oauth_data and \"refresh_token\" in google_oauth_data\n\n        # 3. Test OAuth login via Kakao\n        kakao_oauth_payload = {\"token\": \"mock_kakao_token\"}\n        r = session.post(f\"{BASE_URL}/auth/oauth/kakao\", json=kakao_oauth_payload, timeout=TIMEOUT)\n        assert r.status_code == 200, f\"Kakao OAuth login failed with status {r.status_code}\"\n        kakao_oauth_data = r.json()\n        assert \"access_token\" in kakao_oauth_data and \"refresh_token\" in kakao_oauth_data\n\n        # 4. Validate JWT token expiration and refresh flow\n        # Assume refresh token endpoint: POST /auth/refresh with payload { \"refresh_token\": <token> }\n\n        # Use the refresh token from email login\n        refresh_payload = {\"refresh_token\": tokens['jwt_refresh_token']}\n        r = session.post(f\"{BASE_URL}/auth/refresh\", json=refresh_payload, timeout=TIMEOUT)\n        assert r.status_code == 200, f\"Refresh token failed with status {r.status_code}\"\n        refresh_data = r.json()\n        assert \"access_token\" in refresh_data\n\n        new_access_token = refresh_data[\"access_token\"]\n        decoded_new_token = jwt.decode(new_access_token, options={\"verify_signature\": False})\n        assert decoded_new_token.get(\"exp\") > time.time()\n\n        # 5. Validate access token usage on a protected endpoint\n        # Assume GET /dashboard requires Bearer token auth\n        headers = {\"Authorization\": f\"Bearer {new_access_token}\"}\n        r = session.get(f\"{BASE_URL}/dashboard\", headers=headers, timeout=TIMEOUT)\n        assert r.status_code == 200, f\"Access with JWT token failed, status {r.status_code}\"\n\n        # 6. Test expired token behavior (simulate by using an expired token)\n        # Fake expired token by setting exp in past and encoding\n        expired_token = jwt.encode({\"sub\": \"user\", \"exp\": int(time.time()) - 10}, \"secret\", algorithm=\"HS256\")\n\n        headers_expired = {\"Authorization\": f\"Bearer {expired_token}\"}\n        r = session.get(f\"{BASE_URL}/dashboard\", headers=headers_expired, timeout=TIMEOUT)\n        # Should be unauthorized or forbidden\n        assert r.status_code in (401, 403), f\"Expected 401/403 for expired token, got {r.status_code}\"\n\n    finally:\n        # Cleanup: delete user created (if applicable)\n        if user_id:\n            try:\n                # Need admin or token to delete user, assume admin token or user token can delete own account\n                admin_token = None\n\n                # Try to login admin or reuse user token for deletion\n                admin_login_payload = {\"email\": \"admin@example.com\", \"password\": \"AdminPass123!\"}\n                admin_login_resp = session.post(f\"{BASE_URL}/auth/login\", json=admin_login_payload, timeout=TIMEOUT)\n                if admin_login_resp.status_code == 200:\n                    admin_token = admin_login_resp.json().get(\"access_token\")\n                else:\n                    admin_token = tokens.get('jwt_access_token')\n\n                if admin_token:\n                    del_headers = {\"Authorization\": f\"Bearer {admin_token}\"}\n                    del_resp = session.delete(f\"{BASE_URL}/users/{user_id}\", headers=del_headers, timeout=TIMEOUT)\n                    # If deletion not allowed, ignore error\n                    if del_resp.status_code not in (200, 204, 404):\n                        pass\n            except Exception:\n                pass\n\n\ntest_user_authentication_oauth_jwt_handling()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 3, in <module>\nModuleNotFoundError: No module named 'jwt'\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-12T19:34:14.919Z",
    "modified": "2025-12-12T19:34:59.283Z"
  },
  {
    "projectId": "7907cc9c-a3f2-4224-b26e-c0b5513fc8cc",
    "testId": "d77ceee1-395c-423d-8c2b-66ae4a307be2",
    "userId": "7438b4f8-1041-70be-62a0-849244df0173",
    "title": "TC002-dashboard portfolio and trading statistics display",
    "description": "Verify that the main dashboard correctly displays the user's portfolio overview, balance, and trading statistics reflecting the backend data accurately.",
    "code": "import requests\nimport sqlite3\nimport base64\nimport json\nimport time\nfrom unittest import mock\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\nDATABASE_PATH = \"./test_db.sqlite\"\n\n# Mock Bitget REST API responses to avoid real network calls.\ndef mock_bitget_api(*args, **kwargs):\n    class MockResponse:\n        def __init__(self, json_data, status_code=200):\n            self._json_data = json_data\n            self.status_code = status_code\n\n        def json(self):\n            return self._json_data\n\n    # Return example mocked response data for Bitget API\n    if args[0].startswith(\"https://api.bitget.com\"):\n        # Fake positions and trades data\n        return MockResponse({\n            \"positions\": [\n                {\"symbol\": \"BTCUSDT\", \"size\": 0.5, \"entryPrice\": 45000, \"unrealizedPNL\": 100},\n            ],\n            \"trades\": [\n                {\"id\": \"trade1\", \"symbol\": \"BTCUSDT\", \"price\": 44000, \"qty\": 0.5, \"side\": \"buy\", \"timestamp\": int(time.time()*1000)}\n            ]\n        })\n    return MockResponse({}, 404)\n\n\ndef get_jwt_token(email: str, password: str) -> str:\n    # Helper function to login and get auth token\n    resp = requests.post(\n        f\"{BASE_URL}/api/auth/login\",\n        json={\"email\": email, \"password\": password},\n        timeout=TIMEOUT,\n    )\n    resp.raise_for_status()\n    data = resp.json()\n    assert \"access_token\" in data\n    return data[\"access_token\"]\n\n\ndef insert_test_portfolio_data(conn, user_id: int):\n    cursor = conn.cursor()\n    # Clear existing data for clean test\n    cursor.execute(\"DELETE FROM portfolios WHERE user_id = ?\", (user_id,))\n    cursor.execute(\"DELETE FROM trades WHERE user_id = ?\", (user_id,))\n    conn.commit()\n\n    # Insert portfolio overview\n    cursor.execute(\n        \"INSERT INTO portfolios (user_id, asset, quantity, average_price) VALUES (?, ?, ?, ?)\",\n        (user_id, \"BTC\", 1.2, 40000.0),\n    )\n    # Insert some trading stats records\n    cursor.execute(\n        \"INSERT INTO trades (user_id, symbol, quantity, price, side, timestamp) VALUES (?, ?, ?, ?, ?, ?)\",\n        (user_id, \"BTCUSDT\", 0.5, 44000.0, \"buy\", int(time.time()) - 3600),\n    )\n    cursor.execute(\n        \"INSERT INTO trades (user_id, symbol, quantity, price, side, timestamp) VALUES (?, ?, ?, ?, ?, ?)\",\n        (user_id, \"BTCUSDT\", 0.7, 46000.0, \"sell\", int(time.time()) - 1800),\n    )\n    conn.commit()\n\n\ndef decode_jwt_no_verify(token: str) -> dict:\n    # Decode JWT token payload without verification\n    try:\n        parts = token.split('.')\n        if len(parts) != 3:\n            raise ValueError(\"Invalid JWT token format\")\n        payload_b64 = parts[1]\n        # Add padding if necessary\n        padding = '=' * (-len(payload_b64) % 4)\n        payload_b64 += padding\n        decoded_bytes = base64.urlsafe_b64decode(payload_b64)\n        payload = json.loads(decoded_bytes)\n        return payload\n    except Exception as e:\n        raise AssertionError(f\"Failed to decode JWT token payload: {e}\")\n\n\ndef test_dashboard_portfolio_and_trading_statistics_display():\n    # This function tests that the dashboard endpoint returns portfolio overview, balance,\n    # and trading statistics correctly reflecting the data stored in SQLite database.\n    # It mocks Bitget API and uses SQLite for backend data validation.\n\n    # Credentials for login - this should be a test user set up in the test environment\n    test_email = \"testuser@example.com\"\n    test_password = \"TestPassword123\"\n\n    # Step 1: Get JWT auth token\n    token = get_jwt_token(test_email, test_password)\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n\n    # Step 2: Setup SQLite test database connection\n    conn = sqlite3.connect(DATABASE_PATH)\n    try:\n        # Identify user_id from JWT token for the test user\n        decoded = decode_jwt_no_verify(token)\n        user_id = decoded.get(\"sub\")\n        assert user_id is not None\n\n        # Step 3: Insert test portfolio and trades data for the user to validate dashboard\n        insert_test_portfolio_data(conn, user_id)\n\n        with mock.patch(\"requests.get\", side_effect=mock_bitget_api):\n            # Step 4: Request dashboard data from backend\n            resp = requests.get(f\"{BASE_URL}/api/dashboard\", headers=headers, timeout=TIMEOUT)\n            resp.raise_for_status()\n            dashboard_data = resp.json()\n\n            # Step 5: Validate portfolio overview\n            portfolio = dashboard_data.get(\"portfolio_overview\")\n            assert portfolio is not None, \"Portfolio overview is missing\"\n            btc_holding = next((p for p in portfolio if p[\"asset\"] == \"BTC\"), None)\n            assert btc_holding is not None, \"BTC holding not found in portfolio overview\"\n            assert abs(btc_holding[\"quantity\"] - 1.2) < 0.0001, \"BTC quantity mismatch\"\n\n            # Step 6: Validate balance info\n            balance = dashboard_data.get(\"balance\")\n            assert balance is not None, \"Balance data is missing\"\n            assert isinstance(balance.get(\"total\"), (int, float)), \"Total balance must be numeric\"\n\n            # Step 7: Validate trading statistics\n            trading_stats = dashboard_data.get(\"trading_statistics\")\n            assert trading_stats is not None, \"Trading statistics missing\"\n            # Check example stats keys (total trades, profit/loss, etc)\n            assert \"total_trades\" in trading_stats\n            assert \"profit_loss\" in trading_stats\n\n            # Additional validation: trading stats total_trades should reflect DB\n            cursor = conn.cursor()\n            cursor.execute(\"SELECT COUNT(*) FROM trades WHERE user_id = ?\", (user_id,))\n            trade_count_db = cursor.fetchone()[0]\n            assert trading_stats[\"total_trades\"] == trade_count_db, \"Total trades count mismatch\"\n\n    finally:\n        conn.close()\n\n\ntest_dashboard_portfolio_and_trading_statistics_display()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 149, in <module>\n  File \"<string>\", line 100, in test_dashboard_portfolio_and_trading_statistics_display\n  File \"<string>\", line 43, in get_jwt_token\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8000/api/auth/login\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-12T19:34:14.924Z",
    "modified": "2025-12-12T19:35:26.324Z"
  },
  {
    "projectId": "7907cc9c-a3f2-4224-b26e-c0b5513fc8cc",
    "testId": "b65c4437-c15d-4c7d-9cb3-ca22d74546d1",
    "userId": "7438b4f8-1041-70be-62a0-849244df0173",
    "title": "TC003-bot management create start stop and monitor bots",
    "description": "Test the creation, starting, stopping, and monitoring of AI Trend and Grid trading bots ensuring data persistence and correct bot state transitions.",
    "code": "import requests\nfrom unittest import mock\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\n# Mocked responses for Bitget REST API calls\ndef mock_bitget_api(*args, **kwargs):\n    class MockResponse:\n        def json(self):\n            return {\"result\": \"success\"}\n        @property\n        def status_code(self):\n            return 200\n        @property\n        def text(self):\n            return str(self.json())\n    return MockResponse()\n\ndef test_bot_management_create_start_stop_monitor():\n    # Mock Bitget external API calls inside bot operations\n    with mock.patch(\"requests.post\", side_effect=mock_bitget_api), mock.patch(\"requests.get\", side_effect=mock_bitget_api):\n        # Step 1: Create a Grid Bot\n        create_payload = {\n            \"bot_type\": \"grid\",\n            \"name\": \"Test Grid Bot\",\n            \"config\": {\n                \"grid_size\": 10,\n                \"start_price\": 100,\n                \"end_price\": 150,\n                \"base_currency\": \"USDT\",\n                \"quote_currency\": \"BTC\"\n            }\n        }\n        create_response = requests.post(f\"{BASE_URL}/api/bots\", json=create_payload, timeout=TIMEOUT)\n        assert create_response.status_code == 201, f\"Bot creation failed: {create_response.text}\"\n        bot = create_response.json()\n        bot_id = bot.get(\"id\")\n        assert bot_id is not None, \"Bot ID not returned in creation response\"\n\n        try:\n            # Step 2: Start the Bot\n            start_response = requests.post(f\"{BASE_URL}/api/bots/{bot_id}/start\", timeout=TIMEOUT)\n            assert start_response.status_code == 200, f\"Bot start failed: {start_response.text}\"\n            start_data = start_response.json()\n            assert start_data.get(\"status\") == \"running\", \"Bot status is not running after start\"\n\n            # Step 3: Monitor Bot Status - Should be 'running'\n            status_response = requests.get(f\"{BASE_URL}/api/bots/{bot_id}/status\", timeout=TIMEOUT)\n            assert status_response.status_code == 200, f\"Failed to get bot status: {status_response.text}\"\n            status_data = status_response.json()\n            assert status_data.get(\"status\") == \"running\", \"Bot status not running while started\"\n\n            # Step 4: Stop the Bot\n            stop_response = requests.post(f\"{BASE_URL}/api/bots/{bot_id}/stop\", timeout=TIMEOUT)\n            assert stop_response.status_code == 200, f\"Bot stop failed: {stop_response.text}\"\n            stop_data = stop_response.json()\n            assert stop_data.get(\"status\") == \"stopped\", \"Bot status is not stopped after stop\"\n\n            # Step 5: Check Bot Status - Should be 'stopped'\n            status_response_2 = requests.get(f\"{BASE_URL}/api/bots/{bot_id}/status\", timeout=TIMEOUT)\n            assert status_response_2.status_code == 200, f\"Failed to get bot status after stop: {status_response_2.text}\"\n            status_data_2 = status_response_2.json()\n            assert status_data_2.get(\"status\") == \"stopped\", \"Bot status not stopped after stop\"\n\n            # Step 6: Test Position Closing Logic - simulate closing positions if applicable\n            # For this test, assume endpoint to close positions: POST /api/bots/{bot_id}/positions/close\n            close_response = requests.post(f\"{BASE_URL}/api/bots/{bot_id}/positions/close\", timeout=TIMEOUT)\n            assert close_response.status_code == 200, f\"Closing positions failed: {close_response.text}\"\n            close_data = close_response.json()\n            assert close_data.get(\"result\") == \"positions_closed\", \"Positions were not closed correctly\"\n\n            # Step 7: Validate Data Persistence by fetching the bot info again\n            get_bot_response = requests.get(f\"{BASE_URL}/api/bots/{bot_id}\", timeout=TIMEOUT)\n            assert get_bot_response.status_code == 200, f\"Fetching bot info failed: {get_bot_response.text}\"\n            get_bot_data = get_bot_response.json()\n            assert get_bot_data.get(\"id\") == bot_id, \"Fetched bot ID does not match\"\n            assert get_bot_data.get(\"name\") == \"Test Grid Bot\", \"Bot name mismatch after operations\"\n            assert get_bot_data.get(\"status\") == \"stopped\", \"Bot status mismatch after stop\"\n\n        finally:\n            # Cleanup: Delete the created bot to maintain test isolation\n            delete_response = requests.delete(f\"{BASE_URL}/api/bots/{bot_id}\", timeout=TIMEOUT)\n            assert delete_response.status_code in (200, 204), f\"Failed to delete bot: {delete_response.text}\"\n\n\ntest_bot_management_create_start_stop_monitor()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 87, in <module>\n  File \"<string>\", line 36, in test_bot_management_create_start_stop_monitor\nAssertionError: Bot creation failed: {'result': 'success'}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-12T19:34:14.930Z",
    "modified": "2025-12-12T19:35:36.395Z"
  },
  {
    "projectId": "7907cc9c-a3f2-4224-b26e-c0b5513fc8cc",
    "testId": "68f476c9-5f36-45a6-9513-8f79f3ba9b83",
    "userId": "7438b4f8-1041-70be-62a0-849244df0173",
    "title": "TC004-grid bot templates application and backtesting",
    "description": "Validate that users can apply AI-recommended grid bot templates and run backtests with accurate performance results and correct parameter handling.",
    "code": "import requests\nfrom unittest import mock\nimport json\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\n# Mock responses for external Bitget REST API calls used internally in bot creation and position closing logic\n# Assume the backend calls Bitget API endpoints like /api/bitget/positions/close and /api/bitget/orders/create etc.\n# We'll patch requests.post or requests.get used by backend during test via side_effect mocks.\n\ndef test_grid_bot_templates_application_and_backtesting():\n    \"\"\"\n    Validate applying AI-recommended grid bot templates and running backtests with accurate results.\n    Mock Bitget external API calls to avoid real network calls.\n    Use SQLite DB (assumed by backend).\n    Focus on position closing logic and bot creation flow.\n    \"\"\"\n    # Authentication: assuming test user credentials and token generation endpoint\n    # First, login or register user to get JWT token for authorization\n    # For this test, we'll create a test user and get token or use a stub token if applicable.\n    # Here we simulate login and obtaining a token.\n    auth_url = f\"{BASE_URL}/api/auth/login\"\n    login_payload = {\"email\": \"testuser@example.com\", \"password\": \"TestPassword123!\"}\n    \n    with requests.Session() as session:\n        login_resp = session.post(auth_url, json=login_payload, timeout=TIMEOUT)\n        assert login_resp.status_code == 200, f\"Login failed: {login_resp.text}\"\n        login_data = login_resp.json()\n        token = login_data.get(\"access_token\")\n        assert token, \"No access token returned on login\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {token}\",\n            \"Content-Type\": \"application/json\",\n        }\n\n        # Step 1: Get list of AI-recommended grid bot templates\n        templates_url = f\"{BASE_URL}/api/grid-templates/recommended\"\n        templates_resp = session.get(templates_url, headers=headers, timeout=TIMEOUT)\n        assert templates_resp.status_code == 200, f\"Failed to get recommended templates: {templates_resp.text}\"\n        templates = templates_resp.json()\n        assert isinstance(templates, list) and len(templates) > 0, \"No recommended grid bot templates found\"\n        \n        # Pick a template to apply\n        template_to_apply = templates[0]\n        template_id = template_to_apply.get(\"id\")\n        assert template_id, \"Selected template missing id\"\n\n        # Mock external Bitget API calls\n        # Assuming backend calls 'requests.post' to Bitget API endpoints on bot creation & position closing\n        # We'll patch 'requests.post' to simulate Bitget API responses for these calls\n        \n        def mock_bitget_post(url, *args, **kwargs):\n            # Simulate Bitget API endpoints responses\n            if url.startswith(\"https://api.bitget.com/api/spot/v1/positions/close\"):\n                # Simulate successful position close response\n                return mock.Mock(status_code=200, json=lambda: {\"success\": True, \"message\": \"Position closed\"})\n            if url.startswith(\"https://api.bitget.com/api/spot/v1/orders\"):\n                # Simulate order creation success\n                return mock.Mock(status_code=200, json=lambda: {\"success\": True, \"order_id\": \"123456\"})\n            # Default mock successful response for other Bitget API POST calls\n            return mock.Mock(status_code=200, json=lambda: {\"success\": True})\n\n        with mock.patch(\"requests.post\", side_effect=mock_bitget_post):\n\n            # Step 2: Apply selected template to create a grid bot\n            apply_url = f\"{BASE_URL}/api/bots/grid\"\n            apply_payload = {\n                \"template_id\": template_id,\n                \"bot_name\": \"Test Grid Bot Application\",\n                \"initial_balance\": 1000,\n                \"parameters\": template_to_apply.get(\"parameters\", {}),\n            }\n            create_resp = session.post(apply_url, headers=headers, json=apply_payload, timeout=TIMEOUT)\n            assert create_resp.status_code == 201, f\"Failed to create grid bot: {create_resp.text}\"\n            bot_data = create_resp.json()\n            bot_id = bot_data.get(\"id\")\n            assert bot_id, \"Created grid bot missing id\"\n\n            try:\n                # Step 3: Run backtest on the applied template/bot with historical data parameters\n                backtest_url = f\"{BASE_URL}/api/grid-templates/{template_id}/backtest\"\n                backtest_params = {\n                    \"start_date\": \"2023-01-01\",\n                    \"end_date\": \"2023-06-01\",\n                    \"initial_balance\": 1000,\n                    \"parameters\": template_to_apply.get(\"parameters\", {}),\n                }\n                backtest_resp = session.post(backtest_url, headers=headers, json=backtest_params, timeout=TIMEOUT)\n                assert backtest_resp.status_code == 200, f\"Backtest failed: {backtest_resp.text}\"\n                backtest_result = backtest_resp.json()\n\n                # Validate backtest result contains accurate performance results and relevant metrics\n                for key in [\"total_return\", \"max_drawdown\", \"sharpe_ratio\", \"trades\"]:\n                    assert key in backtest_result, f\"Backtest result missing key: {key}\"\n\n                # Validate trades parameter handling - each trade should have required fields\n                trades = backtest_result.get(\"trades\", [])\n                assert isinstance(trades, list), \"Backtest trades should be a list\"\n                if trades:\n                    trade = trades[0]\n                    for field in [\"entry_price\", \"exit_price\", \"profit_loss\", \"quantity\"]:\n                        assert field in trade, f\"Trade missing field: {field}\"\n\n                # Step 4: Test position closing logic via API call on the created bot (mocked Bitget closes position)\n                close_position_url = f\"{BASE_URL}/api/bots/{bot_id}/positions/close\"\n                close_resp = session.post(close_position_url, headers=headers, timeout=TIMEOUT)\n                assert close_resp.status_code == 200, f\"Position close failed: {close_resp.text}\"\n                close_data = close_resp.json()\n                assert close_data.get(\"success\") is True, \"Position closing was not successful\"\n\n            finally:\n                # Cleanup: delete created bot after test to keep DB clean\n                delete_url = f\"{BASE_URL}/api/bots/{bot_id}\"\n                del_resp = session.delete(delete_url, headers=headers, timeout=TIMEOUT)\n                assert del_resp.status_code == 204, f\"Failed to delete grid bot: {del_resp.text}\"\n\n\ntest_grid_bot_templates_application_and_backtesting()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 120, in <module>\n  File \"<string>\", line 28, in test_grid_bot_templates_application_and_backtesting\nAssertionError: Login failed: {\"success\":false,\"error\":{\"code\":\"HTTP_ERROR\",\"message\":\"Not Found\",\"details\":{},\"timestamp\":\"2025-12-12T19:34:55.892531\",\"request_id\":null}}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-12T19:34:14.935Z",
    "modified": "2025-12-12T19:35:00.366Z"
  },
  {
    "projectId": "7907cc9c-a3f2-4224-b26e-c0b5513fc8cc",
    "testId": "d7ded269-b73d-44f1-9617-acef9c5ac8b1",
    "userId": "7438b4f8-1041-70be-62a0-849244df0173",
    "title": "TC005-admin grid template manager crud and backtesting",
    "description": "Test admin functionalities for creating, updating, deleting grid bot templates and running backtests without errors and with correct data updates.",
    "code": "import requests\nfrom unittest import mock\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\nADMIN_AUTH_TOKEN = \"admin-test-jwt-token\"  # Assume a valid admin JWT token for authentication in tests\n\n\ndef get_admin_headers():\n    return {\n        \"Authorization\": f\"Bearer {ADMIN_AUTH_TOKEN}\",\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"application/json\",\n    }\n\n\n# Mock for external Bitget REST API calls used internally by backtesting or bot creation logic\ndef mock_bitget_api(*args, **kwargs):\n    # Simulate a successful API call returning dummy data\n    class MockResponse:\n        def json(self_inner):\n            return {\"result\": \"success\"}\n\n        @property\n        def status_code(self_inner):\n            return 200\n\n        def raise_for_status(self_inner):\n            pass\n\n    return MockResponse()\n\n\n@mock.patch(\"requests.get\", side_effect=mock_bitget_api)\n@mock.patch(\"requests.post\", side_effect=mock_bitget_api)\n@mock.patch(\"requests.put\", side_effect=mock_bitget_api)\n@mock.patch(\"requests.delete\", side_effect=mock_bitget_api)\ndef test_admin_grid_template_manager_crud_and_backtesting(mock_delete, mock_put, mock_post, mock_get):\n    # Use a try-finally block to ensure cleanup\n\n    template_id = None\n    try:\n        # 1. Create a new grid bot template (Admin Create)\n        create_payload = {\n            \"name\": \"Test Grid Template\",\n            \"description\": \"Template for testing CRUD operations\",\n            \"parameters\": {\n                \"grid_levels\": 5,\n                \"grid_spacing\": 0.01,\n                \"grid_interval\": 60,\n                \"bot_type\": \"grid\",\n                \"initial_investment\": 1000\n            },\n            \"is_active\": True\n        }\n        create_resp = requests.post(\n            f\"{BASE_URL}/admin/grid-templates\",\n            headers=get_admin_headers(),\n            json=create_payload,\n            timeout=TIMEOUT,\n        )\n        assert create_resp.status_code == 201 or create_resp.status_code == 200\n        created_data = create_resp.json()\n        assert \"id\" in created_data\n        template_id = created_data[\"id\"]\n        assert created_data[\"name\"] == create_payload[\"name\"]\n        assert created_data[\"parameters\"][\"grid_levels\"] == 5\n        assert created_data[\"parameters\"].get(\"grid_interval\") == 60\n\n        # 2. Update the grid bot template (Admin Update)\n        update_payload = {\n            \"name\": \"Test Grid Template Updated\",\n            \"description\": \"Updated description for CRUD test\",\n            \"parameters\": {\n                \"grid_levels\": 10,\n                \"grid_spacing\": 0.005,\n                \"grid_interval\": 30,\n                \"bot_type\": \"grid\",\n                \"initial_investment\": 2000\n            },\n            \"is_active\": False\n        }\n        update_resp = requests.put(\n            f\"{BASE_URL}/admin/grid-templates/{template_id}\",\n            headers=get_admin_headers(),\n            json=update_payload,\n            timeout=TIMEOUT,\n        )\n        assert update_resp.status_code == 200\n        updated_data = update_resp.json()\n        assert updated_data[\"name\"] == update_payload[\"name\"]\n        assert updated_data[\"parameters\"][\"grid_levels\"] == 10\n        assert updated_data[\"parameters\"].get(\"grid_interval\") == 30\n        assert updated_data[\"is_active\"] is False\n\n        # 3. Run backtest on the updated template (Admin Backtesting)\n        backtest_payload = {\n            \"template_id\": template_id,\n            \"historical_data_start\": \"2024-01-01T00:00:00Z\",\n            \"historical_data_end\": \"2024-02-01T00:00:00Z\",\n            \"initial_balance\": 10000\n        }\n        backtest_resp = requests.post(\n            f\"{BASE_URL}/admin/grid-templates/{template_id}/backtest\",\n            headers=get_admin_headers(),\n            json=backtest_payload,\n            timeout=TIMEOUT,\n        )\n        assert backtest_resp.status_code == 200\n        backtest_result = backtest_resp.json()\n        # Validate backtest response structure and data presence\n        assert \"performance_metrics\" in backtest_result\n        assert backtest_result[\"performance_metrics\"].get(\"total_return\") is not None\n        assert backtest_result[\"performance_metrics\"].get(\"max_drawdown\") is not None\n        assert \"trades\" in backtest_result\n        assert isinstance(backtest_result[\"trades\"], list)\n\n        # 4. Validate the template appears with updated data on get (Admin Read)\n        get_resp = requests.get(\n            f\"{BASE_URL}/admin/grid-templates/{template_id}\",\n            headers=get_admin_headers(),\n            timeout=TIMEOUT,\n        )\n        assert get_resp.status_code == 200\n        get_data = get_resp.json()\n        assert get_data[\"name\"] == update_payload[\"name\"]\n        assert get_data[\"parameters\"][\"grid_spacing\"] == 0.005\n        assert get_data[\"parameters\"].get(\"grid_interval\") == 30\n        assert get_data[\"is_active\"] is False\n\n    finally:\n        # 5. Delete the grid bot template (Admin Delete)\n        if template_id:\n            del_resp = requests.delete(\n                f\"{BASE_URL}/admin/grid-templates/{template_id}\",\n                headers=get_admin_headers(),\n                timeout=TIMEOUT,\n            )\n            assert del_resp.status_code == 204 or del_resp.status_code == 200\n            # Confirm deletion by attempting to get the template\n            get_after_del_resp = requests.get(\n                f\"{BASE_URL}/admin/grid-templates/{template_id}\",\n                headers=get_admin_headers(),\n                timeout=TIMEOUT,\n            )\n            assert get_after_del_resp.status_code == 404\n\n\ntest_admin_grid_template_manager_crud_and_backtesting()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 150, in <module>\n  File \"/var/lang/lib/python3.12/unittest/mock.py\", line 1396, in patched\n    return func(*newargs, **newkeywargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 65, in test_admin_grid_template_manager_crud_and_backtesting\nAssertionError\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-12T19:34:14.941Z",
    "modified": "2025-12-12T19:35:41.900Z"
  },
  {
    "projectId": "7907cc9c-a3f2-4224-b26e-c0b5513fc8cc",
    "testId": "e297c277-3c3c-4b73-b3be-badb9791d521",
    "userId": "7438b4f8-1041-70be-62a0-849244df0173",
    "title": "TC006-backtesting engine with candle data and performance metrics",
    "description": "Verify the backtesting engine processes historical candle data correctly and produces accurate performance metrics for grid trading strategies.",
    "code": "import requests\nimport sqlite3\nimport json\nfrom unittest import mock\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\n# Mock data for candle data used in backtesting\nMOCK_CANDLE_DATA = [\n    {\"timestamp\": 1672502400, \"open\": 100, \"high\": 110, \"low\": 90, \"close\": 105, \"volume\": 1000},\n    {\"timestamp\": 1672506000, \"open\": 105, \"high\": 115, \"low\": 95, \"close\": 110, \"volume\": 1200},\n    {\"timestamp\": 1672509600, \"open\": 110, \"high\": 120, \"low\": 100, \"close\": 115, \"volume\": 900},\n    {\"timestamp\": 1672513200, \"open\": 115, \"high\": 125, \"low\": 105, \"close\": 120, \"volume\": 1300},\n]\n\n\ndef test_backtesting_engine_with_candle_data_and_performance_metrics():\n    # Setup in-memory SQLite database for testing\n    conn = sqlite3.connect(\":memory:\")\n    try:\n        # Create tables as expected by backtesting service (example schema)\n        conn.execute(\"\"\"\n        CREATE TABLE candle_data (\n            timestamp INTEGER PRIMARY KEY,\n            open REAL,\n            high REAL,\n            low REAL,\n            close REAL,\n            volume REAL\n        )\"\"\")\n        conn.execute(\"\"\"\n        CREATE TABLE bot_instances (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            name TEXT,\n            strategy_config TEXT\n        )\"\"\")\n        conn.commit()\n\n        # Insert mock candle data into candle_data table\n        for candle in MOCK_CANDLE_DATA:\n            conn.execute(\n                \"INSERT INTO candle_data (timestamp, open, high, low, close, volume) VALUES (?, ?, ?, ?, ?, ?)\",\n                (candle['timestamp'], candle['open'], candle['high'], candle['low'], candle['close'], candle['volume'])\n            )\n        conn.commit()\n\n        # Mock authentication token retrieval (assuming JWT token needed)\n        # For this test assume a token is available or use a dummy token for Authorization header\n        auth_token = \"Bearer dummy-jwt-token\"\n\n        headers = {\"Authorization\": auth_token, \"Content-Type\": \"application/json\"}\n\n        # Create a grid trading bot (mocked)\n        bot_payload = {\n            \"name\": \"Test Grid Bot\",\n            \"strategy_type\": \"grid\",\n            \"config\": {\n                \"grid_spacing\": 0.01,\n                \"grid_levels\": 5,\n                \"base_order_size\": 1.0\n            }\n        }\n\n        # Use try-finally to ensure bot is deleted after test\n        create_bot_resp = requests.post(\n            f\"{BASE_URL}/api/bot_instances\",\n            headers=headers,\n            json=bot_payload,\n            timeout=TIMEOUT\n        )\n        assert create_bot_resp.status_code == 201, f\"Bot creation failed: {create_bot_resp.text}\"\n        bot_data = create_bot_resp.json()\n        bot_id = bot_data.get(\"id\")\n        assert bot_id is not None, \"Bot ID not returned on creation\"\n\n        # Mock the external Bitget API calls to avoid real network calls\n        # We patch requests.post/requests.get method used by backtesting internally\n        # Here we assume the backtest endpoint does not call real APIs directly in this test context\n\n        # Prepare backtest request payload with historical candle timestamps and bot id\n        backtest_payload = {\n            \"bot_id\": bot_id,\n            \"start_timestamp\": MOCK_CANDLE_DATA[0]['timestamp'],\n            \"end_timestamp\": MOCK_CANDLE_DATA[-1]['timestamp']\n        }\n\n        # Call backtest endpoint\n        backtest_resp = requests.post(\n            f\"{BASE_URL}/api/backtest/grid\",\n            headers=headers,\n            json=backtest_payload,\n            timeout=TIMEOUT\n        )\n        assert backtest_resp.status_code == 200, f\"Backtest API call failed: {backtest_resp.text}\"\n\n        backtest_result = backtest_resp.json()\n\n        # Validate returned performance metrics exist and are reasonable\n        expected_metrics = [\"total_return\", \"max_drawdown\", \"win_rate\", \"number_of_trades\", \"net_profit\"]\n        for metric in expected_metrics:\n            assert metric in backtest_result, f\"Performance metric '{metric}' missing in backtest result\"\n            # Assert metric values are numbers and sane\n            val = backtest_result[metric]\n            assert isinstance(val, (int, float)), f\"Metric {metric} value is not numeric\"\n            if metric in [\"total_return\", \"net_profit\"]:\n                # These can be positive or negative\n                assert val != 0, f\"Metric {metric} should not be zero for test data\"\n            elif metric == \"win_rate\":\n                assert 0.0 <= val <= 1.0, f\"Win rate {val} not between 0 and 1\"\n            elif metric == \"max_drawdown\":\n                assert val >= 0, f\"Max drawdown {val} should be non-negative\"\n            elif metric == \"number_of_trades\":\n                assert val >= 0 and isinstance(val, int), f\"Number_of_trades {val} invalid\"\n\n        # Test position closing logic by querying backtesting details\n        # Example: examine trades from backtest_result if present\n        trades = backtest_result.get(\"trades\", [])\n        assert isinstance(trades, list), \"Trades field should be a list\"\n        # Check at least one trade is closed properly (closing price exists)\n        trade_closed_correctly = any(\"close_price\" in t and t[\"close_price\"] is not None for t in trades)\n        assert trade_closed_correctly, \"No properly closed positions found in backtest trades\"\n\n    finally:\n        # Clean up: delete created bot instance if it was created\n        if 'bot_id' in locals():\n            try:\n                del_resp = requests.delete(\n                    f\"{BASE_URL}/api/bot_instances/{bot_id}\",\n                    headers=headers,\n                    timeout=TIMEOUT\n                )\n                assert del_resp.status_code in (200, 204), f\"Failed to delete bot: {del_resp.text}\"\n            except Exception:\n                pass\n        conn.close()\n\n\ntest_backtesting_engine_with_candle_data_and_performance_metrics()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 139, in <module>\n  File \"<string>\", line 72, in test_backtesting_engine_with_candle_data_and_performance_metrics\nAssertionError: Bot creation failed: {\"success\":false,\"error\":{\"code\":\"HTTP_ERROR\",\"message\":\"Not Found\",\"details\":{},\"timestamp\":\"2025-12-12T19:35:53.785059\",\"request_id\":null}}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-12T19:34:14.947Z",
    "modified": "2025-12-12T19:35:53.991Z"
  },
  {
    "projectId": "7907cc9c-a3f2-4224-b26e-c0b5513fc8cc",
    "testId": "ce19d4a9-9020-4f9f-9574-8f365916e38e",
    "userId": "7438b4f8-1041-70be-62a0-849244df0173",
    "title": "TC007-real time trading interface with chart and position management",
    "description": "Test the real-time trading interface including live TradingView chart integration, opening, closing, and managing positions with live market data.",
    "code": "import requests\nimport sqlite3\nimport json\nfrom unittest import mock\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\nHEADERS = {\"Content-Type\": \"application/json\"}\n\n# Mocking Bitget API calls inside the tested backend service (assuming endpoint calls it)\n# We will mock requests.post/get used for Bitget API within the backend if such calls are proxied through /external/bitget or similar.\n# Here, we simulate mocking at the requests level for simplicity.\n\ndef mock_bitget_api(*args, **kwargs):\n    # Sample mock response for Bitget API calls\n    class MockResponse:\n        def __init__(self):\n            self.status_code = 200\n            self._json = {\n                \"success\": True,\n                \"data\": {\n                    \"positionId\": \"mock-position-id\",\n                    \"status\": \"closed\"\n                }\n            }\n        def json(self):\n            return self._json\n    return MockResponse()\n\ndef test_real_time_trading_interface_with_chart_and_position_management():\n    # Setup SQLite connection (in-memory for test isolation)\n    conn = sqlite3.connect(\":memory:\")\n    cursor = conn.cursor()\n    try:\n        # Assuming DB schema involves tables: users, bots, positions\n        cursor.executescript(\"\"\"\n        CREATE TABLE users(id INTEGER PRIMARY KEY AUTOINCREMENT, email TEXT UNIQUE, password TEXT);\n        CREATE TABLE bots(id INTEGER PRIMARY KEY AUTOINCREMENT, user_id INTEGER, bot_type TEXT, config TEXT, status TEXT);\n        CREATE TABLE positions(id INTEGER PRIMARY KEY AUTOINCREMENT, bot_id INTEGER, symbol TEXT, side TEXT, qty REAL, status TEXT);\n        \"\"\")\n        conn.commit()\n\n        # 1. Create a test user (simulate signup)\n        test_email = \"testuser@example.com\"\n        test_password = \"securepassword\"\n        cursor.execute(\"INSERT INTO users (email, password) VALUES (?, ?)\", (test_email, test_password))\n        user_id = cursor.lastrowid\n        conn.commit()\n\n        # 2. Mock authentication to get token (simulate login)\n        auth_payload = {\"email\": test_email, \"password\": test_password}\n        login_resp = requests.post(f\"{BASE_URL}/api/auth/login\", json=auth_payload, timeout=TIMEOUT)\n        login_resp.raise_for_status()\n        auth_token = login_resp.json().get(\"access_token\")\n        assert auth_token, \"No access token received\"\n\n        auth_headers = {\"Authorization\": f\"Bearer {auth_token}\", \"Content-Type\": \"application/json\"}\n\n        # 3. Create a bot (bot creation flow)\n        bot_create_payload = {\n            \"bot_type\": \"grid\",\n            \"config\": {\n                \"symbol\": \"BTCUSDT\",\n                \"grid_size\": 10,\n                \"investment\": 1000\n            }\n        }\n        bot_resp = requests.post(f\"{BASE_URL}/api/bots\", headers=auth_headers, json=bot_create_payload, timeout=TIMEOUT)\n        bot_resp.raise_for_status()\n        bot = bot_resp.json()\n        bot_id = bot.get(\"id\")\n        assert bot_id, \"Bot creation failed, no ID returned\"\n\n        # 4. Start the bot\n        start_resp = requests.post(f\"{BASE_URL}/api/bots/{bot_id}/start\", headers=auth_headers, timeout=TIMEOUT)\n        start_resp.raise_for_status()\n        assert start_resp.json().get(\"status\") == \"running\"\n\n        # 5. Open a position using the bot - note: Position opening API assumed as /api/positions with bot_id\n        position_payload = {\n            \"bot_id\": bot_id,\n            \"symbol\": \"BTCUSDT\",\n            \"side\": \"buy\",\n            \"quantity\": 0.1\n        }\n\n        # Patch requests.post inside this scope to mock Bitget API calls the backend would make internally\n        with mock.patch(\"requests.post\", side_effect=mock_bitget_api):\n            pos_resp = requests.post(f\"{BASE_URL}/api/positions\", headers=auth_headers, json=position_payload, timeout=TIMEOUT)\n            pos_resp.raise_for_status()\n            position = pos_resp.json()\n            position_id = position.get(\"id\")\n            assert position_id, \"Position opening failed, no position ID returned\"\n            assert position.get(\"status\") == \"open\"\n\n            # 6. Fetch live TradingView chart data (simulated via endpoint /api/trading/chart)\n            chart_resp = requests.get(f\"{BASE_URL}/api/trading/chart?symbol=BTCUSDT\", headers=auth_headers, timeout=TIMEOUT)\n            chart_resp.raise_for_status()\n            chart_data = chart_resp.json()\n            assert \"candles\" in chart_data and isinstance(chart_data[\"candles\"], list)\n\n            # 7. Close the position to test position closing logic\n            close_resp = requests.post(f\"{BASE_URL}/api/positions/{position_id}/close\", headers=auth_headers, timeout=TIMEOUT)\n            close_resp.raise_for_status()\n            close_data = close_resp.json()\n            assert close_data.get(\"status\") == \"closed\", \"Position closing status is not closed\"\n\n        # 8. Stop and delete the bot (cleanup)\n        stop_resp = requests.post(f\"{BASE_URL}/api/bots/{bot_id}/stop\", headers=auth_headers, timeout=TIMEOUT)\n        stop_resp.raise_for_status()\n        assert stop_resp.json().get(\"status\") == \"stopped\"\n\n        del_resp = requests.delete(f\"{BASE_URL}/api/bots/{bot_id}\", headers=auth_headers, timeout=TIMEOUT)\n        del_resp.raise_for_status()\n        assert del_resp.status_code == 204\n\n    finally:\n        # Cleanup DB connection\n        conn.close()\n\ntest_real_time_trading_interface_with_chart_and_position_management()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 121, in <module>\n  File \"<string>\", line 53, in test_real_time_trading_interface_with_chart_and_position_management\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8000/api/auth/login\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-12T19:34:14.953Z",
    "modified": "2025-12-12T19:35:49.915Z"
  },
  {
    "projectId": "7907cc9c-a3f2-4224-b26e-c0b5513fc8cc",
    "testId": "b5d21b12-cc1e-4399-8906-d33a940491a2",
    "userId": "7438b4f8-1041-70be-62a0-849244df0173",
    "title": "TC008-trading history accuracy and analytics",
    "description": "Verify that the trading history page displays accurate past trade records and performance analytics matching the recorded trade information.",
    "code": "import requests\nimport sqlite3\nimport json\nimport time\nfrom unittest import mock\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\n# Mocked Bitget API responses for external calls the platform might do during position closing or bot operation\ndef mock_bitget_rest_api(*args, **kwargs):\n    class MockResponse:\n        def __init__(self):\n            self.status_code = 200\n        def json(self):\n            return {\n                \"data\": {\n                    \"order_id\": \"mocked_order_123\",\n                    \"status\": \"closed\",\n                    \"filled_qty\": \"10\",\n                    \"price\": \"100.5\"\n                }\n            }\n    return MockResponse()\n\ndef test_trading_history_accuracy_and_analytics():\n    # Use in-memory SQLite DB to avoid file permission issues\n    conn = sqlite3.connect(':memory:')\n    cursor = conn.cursor()\n    try:\n        # Create minimal schema for trades and performance analytics for testing\n        cursor.executescript(\"\"\"\n            DROP TABLE IF EXISTS trades;\n            DROP TABLE IF EXISTS analytics;\n            CREATE TABLE trades (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                bot_id INTEGER NOT NULL,\n                trade_type TEXT NOT NULL,\n                quantity REAL NOT NULL,\n                price REAL NOT NULL,\n                timestamp INTEGER NOT NULL,\n                status TEXT NOT NULL\n            );\n            CREATE TABLE analytics (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                bot_id INTEGER NOT NULL,\n                total_trades INTEGER,\n                winning_trades INTEGER,\n                losing_trades INTEGER,\n                pnl REAL,\n                timestamp INTEGER NOT NULL\n            );\n        \"\"\")\n        conn.commit()\n\n        # Step 1: Authenticate and get JWT token (simulate user login)\n        # For testing, we assume user already exists with known login\n        login_payload = {\"email\": \"testuser@example.com\", \"password\": \"testpassword\"}\n        login_resp = requests.post(\n            f\"{BASE_URL}/api/auth/login\",\n            json=login_payload,\n            timeout=TIMEOUT\n        )\n        assert login_resp.status_code == 200\n        token = login_resp.json().get(\"access_token\")\n        assert token is not None\n\n        headers = {\"Authorization\": f\"Bearer {token}\", \"Content-Type\": \"application/json\"}\n\n        # Step 2: Create a Grid Bot (to generate trades and analytics)\n        new_bot_payload = {\n            \"name\": \"Test Trading History Bot\",\n            \"strategy\": \"grid\",\n            \"config\": {\n                \"grid_spacing\": 0.01,\n                \"investment\": 1000,\n                \"max_positions\": 5\n            }\n        }\n        create_bot_resp = requests.post(\n            f\"{BASE_URL}/api/bots\",\n            json=new_bot_payload,\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        assert create_bot_resp.status_code == 201\n        bot_id = create_bot_resp.json().get(\"id\")\n        assert bot_id is not None\n\n        # We will mock external Bitget API calls during position closing & bot operation\n        with mock.patch('backend.src.api.bitget_rest_api.requests.post', side_effect=mock_bitget_rest_api), \\\n             mock.patch('backend.src.api.bitget_rest_api.requests.get', side_effect=mock_bitget_rest_api):\n\n            # Step 3: Start the bot to generate some trades (simulate this by API call)\n            start_resp = requests.post(\n                f\"{BASE_URL}/api/bots/{bot_id}/start\",\n                headers=headers,\n                timeout=TIMEOUT\n            )\n            assert start_resp.status_code == 200\n\n            # Wait briefly to let backend simulate trades (in real testing environment)\n            time.sleep(2)\n\n            # Step 4: Stop the bot to finalize trades\n            stop_resp = requests.post(\n                f\"{BASE_URL}/api/bots/{bot_id}/stop\",\n                headers=headers,\n                timeout=TIMEOUT\n            )\n            assert stop_resp.status_code == 200\n\n            # Step 5: Retrieve trading history for this bot\n            history_resp = requests.get(\n                f\"{BASE_URL}/api/trading_history?bot_id={bot_id}\",\n                headers=headers,\n                timeout=TIMEOUT\n            )\n            assert history_resp.status_code == 200\n            trades_data = history_resp.json()\n            assert isinstance(trades_data, list)\n            assert len(trades_data) > 0  # There should be trades recorded\n\n            # Step 6: Verify trades accuracy and match against DB directly\n            cursor.executemany(\n                \"INSERT INTO trades (bot_id, trade_type, quantity, price, timestamp, status) VALUES (?, ?, ?, ?, ?, ?)\",\n                [\n                    (bot_id, trade[\"trade_type\"], trade[\"quantity\"], trade[\"price\"], trade[\"timestamp\"], trade[\"status\"]) \n                    for trade in trades_data\n                ]\n            )\n            conn.commit()\n\n            # Query back inserted trades and compare\n            cursor.execute(\"SELECT bot_id, trade_type, quantity, price, timestamp, status FROM trades WHERE bot_id = ?\", (bot_id,))\n            db_trades = cursor.fetchall()\n            assert len(db_trades) == len(trades_data)\n\n            # Step 7: Retrieve performance analytics for this bot\n            analytics_resp = requests.get(\n                f\"{BASE_URL}/api/trading_history/analytics?bot_id={bot_id}\",\n                headers=headers,\n                timeout=TIMEOUT\n            )\n            assert analytics_resp.status_code == 200\n            analytics_data = analytics_resp.json()\n            assert \"total_trades\" in analytics_data\n            assert \"winning_trades\" in analytics_data\n            assert \"losing_trades\" in analytics_data\n            assert \"pnl\" in analytics_data\n\n            # Insert analytics into DB\n            timestamp = int(time.time())\n            cursor.execute(\"\"\"\n                INSERT INTO analytics (bot_id, total_trades, winning_trades, losing_trades, pnl, timestamp)\n                VALUES (?, ?, ?, ?, ?, ?)\n            \"\"\", (\n                bot_id,\n                analytics_data[\"total_trades\"],\n                analytics_data[\"winning_trades\"],\n                analytics_data[\"losing_trades\"],\n                analytics_data[\"pnl\"],\n                timestamp\n            ))\n            conn.commit()\n\n            # Query and verify analytics data was stored correctly\n            cursor.execute(\"SELECT total_trades, winning_trades, losing_trades, pnl FROM analytics WHERE bot_id = ?\", (bot_id,))\n            db_analytics = cursor.fetchone()\n            assert db_analytics is not None\n            assert db_analytics[0] == analytics_data[\"total_trades\"]\n            assert db_analytics[1] == analytics_data[\"winning_trades\"]\n            assert db_analytics[2] == analytics_data[\"losing_trades\"]\n            assert abs(db_analytics[3] - analytics_data[\"pnl\"]) < 0.0001\n\n    finally:\n        # Cleanup: Delete the created bot\n        try:\n            if 'bot_id' in locals():\n                requests.delete(\n                    f\"{BASE_URL}/api/bots/{bot_id}\",\n                    headers=headers,\n                    timeout=TIMEOUT\n                )\n        except Exception:\n            pass\n        cursor.execute(\"DROP TABLE IF EXISTS trades;\")\n        cursor.execute(\"DROP TABLE IF EXISTS analytics;\")\n        conn.commit()\n        conn.close()\n\ntest_trading_history_accuracy_and_analytics()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 192, in <module>\n  File \"<string>\", line 64, in test_trading_history_accuracy_and_analytics\nAssertionError\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-12T19:34:14.958Z",
    "modified": "2025-12-12T19:36:01.046Z"
  },
  {
    "projectId": "7907cc9c-a3f2-4224-b26e-c0b5513fc8cc",
    "testId": "20225095-f6c2-42f8-b2cc-1b75f49da271",
    "userId": "7438b4f8-1041-70be-62a0-849244df0173",
    "title": "TC009-strategy management configuration and alert triggering",
    "description": "Test the trading strategy configuration and management tools including saving strategies and triggering alerts and notifications based on market events.",
    "code": "import requests\nimport sqlite3\nimport threading\nimport time\nfrom unittest import mock\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\n# Mock Bitget REST API response for position closing and alert triggering\ndef mock_bitget_close_position(*args, **kwargs):\n    class MockResponse:\n        def json(self):\n            return {\"success\": True, \"message\": \"Position closed\"}\n        @property\n        def status_code(self):\n            return 200\n    return MockResponse()\n\ndef mock_bitget_get_market_event(*args, **kwargs):\n    class MockResponse:\n        def json(self):\n            # Simulate a market event that should trigger alert\n            return {\"price\": 105.0, \"symbol\": \"BTCUSDT\"}\n        @property\n        def status_code(self):\n            return 200\n    return MockResponse()\n\ndef test_strategy_management_and_alert_triggering():\n    # Setup SQLite in-memory database connection for testing\n    conn = sqlite3.connect(\":memory:\")\n    try:\n        # Create tables to simulate strategy config and alerts as per backend schema assumptions\n        cursor = conn.cursor()\n        cursor.execute(\"\"\"\n            CREATE TABLE strategies (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                name TEXT NOT NULL,\n                config TEXT NOT NULL\n            )\n        \"\"\")\n        cursor.execute(\"\"\"\n            CREATE TABLE alerts (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                strategy_id INTEGER,\n                alert_type TEXT,\n                triggered BOOLEAN,\n                FOREIGN KEY(strategy_id) REFERENCES strategies(id)\n            )\n        \"\"\")\n        conn.commit()\n\n        # Step 1: Create a new trading strategy via API\n        strategy_payload = {\n            \"name\": \"Test Strategy Alpha\",\n            \"config\": {\n                \"grid_levels\": 5,\n                \"take_profit\": 0.02,\n                \"stop_loss\": 0.01,\n                \"symbol\": \"BTCUSDT\",\n                \"base_order_size\": 0.001\n            }\n        }\n        headers = {\"Content-Type\": \"application/json\"}\n\n        # Create strategy POST /api/strategies (assumed endpoint)\n        response = requests.post(f\"{BASE_URL}/api/strategies\", json=strategy_payload, headers=headers, timeout=TIMEOUT)\n        assert response.status_code == 201, f\"Strategy creation failed: {response.text}\"\n        strategy_data = response.json()\n        strategy_id = strategy_data.get(\"id\")\n        assert strategy_id is not None, \"No strategy ID returned on creation\"\n\n        # Insert strategy to SQLite mock DB to simulate backend persistence\n        cursor.execute(\"INSERT INTO strategies (id, name, config) VALUES (?, ?, ?)\",\n                       (strategy_id, strategy_payload[\"name\"], str(strategy_payload[\"config\"])))\n        conn.commit()\n\n        # Step 2: Simulate position closing logic (mocking Bitget API)\n        with mock.patch('requests.post', side_effect=mock_bitget_close_position):\n            close_position_payload = {\n                \"strategy_id\": strategy_id,\n                \"symbol\": \"BTCUSDT\",\n                \"position_side\": \"LONG\",\n                \"close_amount\": 0.001\n            }\n            close_resp = requests.post(f\"{BASE_URL}/api/positions/close\", json=close_position_payload, headers=headers, timeout=TIMEOUT)\n            assert close_resp.status_code == 200, f\"Position close API failed: {close_resp.text}\"\n            close_resp_json = close_resp.json()\n            assert close_resp_json.get(\"success\") is True, \"Position close was not successful\"\n\n        # Step 3: Simulate alert triggering logic based on market event\n        # Create alert linked to strategy in SQLite mock DB\n        cursor.execute(\"INSERT INTO alerts (strategy_id, alert_type, triggered) VALUES (?, ?, ?)\",\n                       (strategy_id, \"price_threshold\", False))\n        alert_id = cursor.lastrowid\n        conn.commit()\n\n        # Mock GET call to external API to get market event\n        with mock.patch('requests.get', side_effect=mock_bitget_get_market_event):\n            market_event_resp = requests.get(f\"{BASE_URL}/api/market_events/latest?symbol=BTCUSDT\", timeout=TIMEOUT)\n            assert market_event_resp.status_code == 200, f\"Market event fetch failed: {market_event_resp.text}\"\n            event = market_event_resp.json()\n            price = event.get(\"price\")\n            assert price is not None, \"No price in market event\"\n\n            # Business logic: Trigger alert if price crosses 100 (threshold)\n            if price > 100:\n                # Update alert triggered status in SQLite DB to simulate alert firing\n                cursor.execute(\"UPDATE alerts SET triggered = ? WHERE id = ?\", (True, alert_id))\n                conn.commit()\n\n                # Notify backend about alert triggering (POST /api/alerts/trigger)\n                alert_trigger_payload = {\n                    \"alert_id\": alert_id,\n                    \"strategy_id\": strategy_id,\n                    \"event\": event\n                }\n                alert_trigger_resp = requests.post(f\"{BASE_URL}/api/alerts/trigger\", json=alert_trigger_payload, headers=headers, timeout=TIMEOUT)\n                assert alert_trigger_resp.status_code == 200, f\"Alert trigger API failed: {alert_trigger_resp.text}\"\n                alert_trigger_resp_json = alert_trigger_resp.json()\n                assert alert_trigger_resp_json.get(\"notified\") is True, \"Alert notification failed\"\n            else:\n                # No alert triggered; ensure alert record stays untriggered\n                cursor.execute(\"SELECT triggered FROM alerts WHERE id = ?\", (alert_id,))\n                triggered_status = cursor.fetchone()[0]\n                assert triggered_status is False, \"Alert incorrectly triggered\"\n\n        # Step 4: Cleanup - Delete created strategy and alert via API and SQLite DB\n        delete_strategy_resp = requests.delete(f\"{BASE_URL}/api/strategies/{strategy_id}\", headers=headers, timeout=TIMEOUT)\n        assert delete_strategy_resp.status_code in (200,204), f\"Strategy deletion failed: {delete_strategy_resp.text}\"\n        cursor.execute(\"DELETE FROM alerts WHERE id = ?\", (alert_id,))\n        cursor.execute(\"DELETE FROM strategies WHERE id = ?\", (strategy_id,))\n        conn.commit()\n\n    finally:\n        conn.close()\n\ntest_strategy_management_and_alert_triggering()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 139, in <module>\n  File \"<string>\", line 69, in test_strategy_management_and_alert_triggering\nAssertionError: Strategy creation failed: {\"success\":false,\"error\":{\"code\":\"HTTP_ERROR\",\"message\":\"Not Found\",\"details\":{},\"timestamp\":\"2025-12-12T19:35:28.203871\",\"request_id\":null}}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-12T19:34:14.964Z",
    "modified": "2025-12-12T19:35:31.458Z"
  },
  {
    "projectId": "7907cc9c-a3f2-4224-b26e-c0b5513fc8cc",
    "testId": "1c2044f9-7b1d-4437-8a9f-cfffba526acc",
    "userId": "7438b4f8-1041-70be-62a0-849244df0173",
    "title": "TC010-user settings api key management and preferences",
    "description": "Verify that user settings including API key management and preferences are saved correctly and persist in the backend.",
    "code": "import requests\nimport sqlite3\nimport threading\nimport time\nfrom unittest import mock\nimport uuid\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\n# Helper functions to handle user creation and auth\ndef create_user_and_get_token(email, password):\n    # Register user\n    reg_resp = requests.post(\n        f\"{BASE_URL}/api/auth/register\",\n        json={\"email\": email, \"password\": password},\n        timeout=TIMEOUT,\n    )\n    assert reg_resp.status_code == 201\n    # Login user\n    login_resp = requests.post(\n        f\"{BASE_URL}/api/auth/login\",\n        json={\"email\": email, \"password\": password},\n        timeout=TIMEOUT,\n    )\n    assert login_resp.status_code == 200\n    token = login_resp.json().get(\"access_token\")\n    assert token is not None\n    return token\n\ndef get_headers(token):\n    return {\"Authorization\": f\"Bearer {token}\", \"Content-Type\": \"application/json\"}\n\ndef test_user_settings_api_key_management_and_preferences():\n    # Use unique user to avoid conflicts\n    unique_id = uuid.uuid4().hex\n    test_email = f\"testuser_api_settings_{unique_id}@example.com\"\n    test_password = \"StrongPassw0rd!\"\n    token = create_user_and_get_token(test_email, test_password)\n    headers = get_headers(token)\n\n    # Initial get user settings (should be defaults or empty)\n    get_resp = requests.get(f\"{BASE_URL}/api/account/settings\", headers=headers, timeout=TIMEOUT)\n    assert get_resp.status_code == 200\n    settings_before = get_resp.json()\n    assert isinstance(settings_before, dict)\n\n    # Define new API keys and preferences to update\n    new_settings_payload = {\n        \"api_keys\": {\n            \"bitget_api_key\": \"mocked_bitget_api_key_123\",\n            \"bitget_api_secret\": \"mocked_bitget_api_secret_abc\",\n            \"bitget_passphrase\": \"mocked_passphrase_xyz\"\n        },\n        \"preferences\": {\n            \"email_notifications\": True,\n            \"dark_mode\": True,\n            \"default_bot_type\": \"grid\",\n            \"trade_execution_slippage\": 0.05\n        }\n    }\n\n    # Patch requests.post/send inside Bitget API calls to avoid real network calls\n    # Here we mock requests.post globally in this test scope for demonstration\n    with mock.patch(\"requests.post\") as mock_post:\n        mock_post.return_value.status_code = 200\n        mock_post.return_value.json = lambda: {\"mock\": \"response\"}\n\n        # Update user settings with new API keys and preferences\n        put_resp = requests.put(f\"{BASE_URL}/api/account/settings\", headers=headers, json=new_settings_payload, timeout=TIMEOUT)\n        assert put_resp.status_code == 200\n        updated_settings = put_resp.json()\n        assert updated_settings.get(\"api_keys\") == new_settings_payload[\"api_keys\"]\n        assert updated_settings.get(\"preferences\") == new_settings_payload[\"preferences\"]\n\n    # Retrieve again to ensure settings persist correctly\n    get_after_resp = requests.get(f\"{BASE_URL}/api/account/settings\", headers=headers, timeout=TIMEOUT)\n    assert get_after_resp.status_code == 200\n    settings_after = get_after_resp.json()\n    assert settings_after.get(\"api_keys\") == new_settings_payload[\"api_keys\"]\n    assert settings_after.get(\"preferences\") == new_settings_payload[\"preferences\"]\n\n    # Cleanup is not needed for user settings but if API keys are sensitive,\n    # reset them by clearing settings back to empty or defaults (optional)\n    reset_payload = {\n        \"api_keys\": {},\n        \"preferences\": {}\n    }\n    reset_resp = requests.put(f\"{BASE_URL}/api/account/settings\", headers=headers, json=reset_payload, timeout=TIMEOUT)\n    assert reset_resp.status_code == 200\n\ntest_user_settings_api_key_management_and_preferences()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 92, in <module>\n  File \"<string>\", line 39, in test_user_settings_api_key_management_and_preferences\n  File \"<string>\", line 19, in create_user_and_get_token\nAssertionError\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-12T19:34:14.970Z",
    "modified": "2025-12-12T19:36:04.919Z"
  }
]
